내 이름은 Andrew Clark입니다. 나는 지금까지 2년 동안 React 앱을 따라왔습니다. 나는 물론 Dan Abramow와 함께 Redux의 공동 창시자 중 한 명입니다. 또한 reCompose라는 라이브러리를 만들었습니다. 최근에는 Facebook에 합류했습니다. 나는 지난 주에 가입했으므로 아직은 비밀을 알려줄 수 없습니다. 나는 React 팀에서 일할 예정이며 그에 대해 매우 기대하고 있습니다. 오늘은 React Fiber라는 것에 대해 이야기하려고 합니다. 솔직히 말해서 몇 가지 이유로 이 주제에 대해 약간 긴장되었습니다. 이것은 매우 실험적인 것이므로 오늘 당장 사용할 수 있는 것이 아니거나 곧 사용할 수 있는 것은 아닙니다. 이 실험이 실패할 수도 있으며 사용할 수 없을 수도 있습니다. 실제로 작동한다 하더라도 몇 달이 지나야 사용해 볼 수 있을 것이며, 출시되면 실제로는 앱이 더 빨라질 것이므로 아마도 알아채지 못할 것입니다. 우리는 그냥 무언가를 망가뜨리지 않으려고 노력할 것입니다. 마지막으로, 이것은 어떻게 작동하는지 아직 제대로 이해하지 못해서 약간 긴장되고 있습니다. 그래도 그것에 대해 이야기하려고 합니다. 이러한 주의사항을 모두 말한 후에도, Fiber에 대해 이야기하고 여기에 와서 이야기하는 것에 대해 정말 기대되고 있으며, 여러분이 더 많이 배우는 것을 즐길 것이라고 생각합니다. 지난 몇 달 동안 Fiber에 대해 배우는 것을 정말로 즐겼기 때문입니다. 그래서 React Fiber가 무엇인가요? React Fiber는 React의 다음 버전으로, 이 컨퍼런스의 이름에 어울리는 것입니다. 다음 버전의 React라고 말할 때, 16.0 이상의 버전을 의미하는 것이 아니라 React의 핵심 알고리즘, 전체 내부 및 작동 방식을 처음부터 다시 작성하는 것을 의미합니다. 내 의견으로는 이것이 React 세계에서 가장 흥미로운 일입니다. 아직 몇 달은 남았지만, 가까운 미래의 React에 대해 가장 기대하고 있는 것입니다. React 팀의 다른 구성원들도 동의하는 것 같습니다. 몇 일 전에 Christopher Chidol의 React-A-Flex Q&A를 보신 적이 있다면, 그가 똑같은 말을 했을 것입니다. 그래서 손을 들어봅시다. React Fiber에 대해 실제로 들어본 사람은 몇 명이나 있나요? 손이 조금 흩어져 있습니다. 손을 들었다면, 아마도 GitHub이나 Twitter에서 Fiber에 대한 소문을 들은 것일 것입니다. 가끔 새로운 React 버전에 대한 언급을 본 적이 있을 것입니다. 나도 처음에는 그렇게 들었습니다. 왜냐하면 Fiber에 대한 공식 문서는 실제로는 없기 때문입니다. React Fiber 아키텍처라는 문서를 작성한 것을 본 적이 있을 수도 있습니다. 그것은 공식 문서가 아니라 외부인이 실제로는 잘 이해하지 못하는 것을 이해하려고 노력한 것입니다. 그리고 아직 문서화되지 않았습니다. 왜냐하면 아직 실험적이기 때문입니다. 그리고 나는 두 번이나 그렇게 말했습니다. 그래서 경고를 받으십시오. 좀 더 역사적인 내용을 조금 알려드리겠습니다. React 팀은 실제로 React Fiber라고 불리기 전에도 Fiber에 대해 작업해 왔습니다. 최근에 다시 발견한 트윗이 있습니다. 이 트윗은 2014년 8월에 작성되었으며, 그 이후로 React 팀은 React의 새로운 버전에 대한 많은 실험, 연구 및 프로토타입을 진행했습니다. Fiber는 실험의 최신 버전일 뿐입니다. 그러나 이 실험과는 다르게 현재 GitHub 프로젝트에서 Fiber에 대한 실제 커밋이 이루어지고 있으므로 실제로 구현되는 것에 점점 가까워지고 있습니다. 그리고 이것은 실험적인 것이라고 했습니다. 혹시 이 버전이 완성되지 않더라도 비슷한 것이 나올 것입니다. 그래서 지금 완전히 완성되지 않은 것을 보여주는 것에 대해 너무 미안해하지 않아도 됩니다. 그렇지만 지금 바로 GitHub에 가서 구현되는 과정을 따라갈 수 있습니다. 나는 오늘 이 발표에서 몇 가지 목표를 가지고 있습니다. 왜 Fiber가 존재하는지에 대해 이야기하려고 합니다. 왜 React를 다시 작성하려고 하는 것인지에 대해 이야기하려고 합니다. 그것이 제가 이야기하려는 한 가지 포인트입니다. Fiber가 어떻게 작동하는지에 대해 약간 이야기하려고 합니다. 구현 측면에서 말이죠. 그리고 이것이 React가 할 수 있는 기능과 멋진 기능들에 대해 이야기하려고 합니다. Fiber가 React에게 열어줄 수 있는 것들입니다. 대부분의 내용은 React Fiber에 대해 정말 흥분하고 있기 때문에 여러분을 열정적으로 만들고 싶습니다. 저는 정말로 그것에 대해 흥분하고 있습니다. 여러분도 그것에 대해 흥분하게 만들 수 있다면, 이 발표를 성공으로 여기겠습니다. 그러면 먼저, 왜 React를 다시 작성해야 하는 걸까요? 몇 가지 이유가 있습니다. 먼저 스케줄링이라는 주제로 시작하겠습니다. 스케줄링은 컴퓨팅의 다른 맥락에서 다른 의미를 가질 수 있는 용어입니다. 그러나 React의 컨텍스트에서 스케줄링은 작업이 언제 수행되어야 하는지를 결정하는 과정입니다. 여기서 작업이라 함은 React의 컨텍스트에서 조정과 같은 작업을 의미합니다. 예를 들어 DOM 차이 비교입니다. React의 컨텍스트에서 스케줄링이란 무엇을 의미할까요? React에서 중요한 개념 중 하나는 UI가 선언적으로 표현된다는 것입니다. DOM을 명령적으로 변경하는 대신, 주어진 데이터 집합에 대한 URI 설명을 반환할 수 있습니다. 이것이 React의 핵심 전제입니다. 이것은 앱을 효율적으로 한 상태에서 다른 상태로 전환하는 방법을 걱정할 필요가 없다는 것을 의미합니다. A에서 B로, B에서 C로, C에서 B로, X에서 G로 전환하는 방법을 걱정할 필요가 없습니다. React가 모두 처리해줍니다. 이로 인해 앱을 구조화하는 데 큰 이점이 있습니다. 이에 대해 자세히 언급하지는 않겠습니다. 이것은 고급 발표입니다. 여기에 있는 모든 사람들은 이미 React를 사용해 본 적이 있을 것입니다. 그래서 이에 대해 자세히 언급하지는 않겠습니다. 우리는 모두 컴포넌트가 작업하기에 훌륭하다는 것을 알고 있습니다. 그러나 개발자에게 더 나은 패러다임이 되는 것 외에도 React의 선언적인 특성은 React에게 스케줄링의 통제권을 주는 아주 좋은 기능을 제공합니다. React는 UI를 업데이트하는 방법뿐만 아니라 언제 업데이트할지도 결정해야 합니다. 좀 더 구체적으로 말하자면, set state를 호출할 때 set state의 계약은 React에게 "이 컴포넌트가 변경되었으니 UI를 업데이트하는 최선의 시기에 업데이트해주세요"라고 말하는 것과 같습니다. 이것은 push 대 pull의 개념과 비슷합니다. push 기반 접근 방식은 앱(즉, 프로그래머인 여러분)이 작업을 스케줄링하는 방법을 결정해야 한다는 것을 의미합니다. pull 기반 접근 방식은 프레임워크, 이 경우에는 React가 스케줄링 결정을 내리는 데에 더 똑똑할 수 있도록 허용하는 것입니다. React는 push 대신 pull 기반 패러다임입니다. FRP 스타일의 UI 라이브러리(Cycle 등) 중 하나가 push 기반 패러다임의 예입니다. 이 개념이 특별한 이유는 React가 다른 종류의 작업에 우선순위를 부여할 수 있다는 것입니다. React 앱에서 업데이트 및 다시 렌더링이 어떻게 트리거되는지 생각해 보겠습니다. 사용자 이벤트(클릭 또는 폼 입력 변경)가 있습니다. 외부 데이터 구독(redux 또는 relay, mobex 등)이 있습니다. 그리고 애니메이션이 있습니다. 예를 들어 요소가 한 가지에서 다른 가지로 전환되는 것입니다. 아마도 어떤 제스처를 수행하고 그것을 애니메이션화하여 멋지게 표시하려고 할 것입니다. 현재 버전의 React는 스케줄링을 크게 활용하지 않기 때문에 이러한 다른 유형의 다시 렌더링은 기본적으로 동일하게 처리됩니다. 컴포넌트의 set state가 호출되면 해당 컴포넌트와 그 하위 트리가 재귀적으로 동기적으로 다시 렌더링됩니다. 그러나 스케줄링을 제어할 수 있다면, 더 중요한 작업에 더 높은 우선순위를 부여할 수 있습니다. 예를 들어, Redux 스토어의 새 데이터로 인해 트리거된 업데이트와 초당 60프레임으로 발생하는 애니메이션으로 인해 발생한 다시 렌더링 중 어떤 것이 먼저 발생해야 할까요? Redux 스토어 업데이트인가요? 아니면 애니메이션인가요? 답은 애니메이션입니다. 애니메이션 프레임이 누락되면 사용자 경험이 나빠집니다. Redux 스토어의 새 데이터가 화면에 나타나기까지 한 프레임이 더 걸린다면, 아무도 그것을 알아채지 못할 것입니다. 그것은 인지할 수 없는 것입니다. 그러나 누락된 프레임은 사람들이 쉽게 알아챕니다. 그것은 나쁜 사용자 경험으로 이어집니다. 애니메이션을 부드럽게 유지하는 것이 정말 중요합니다. 이것은 우리에게는 상식적으로 보일 수 있습니다. 중요한 정보라고 생각할 수도 있습니다. 애니메이션은 시각적인 장식일 뿐입니다. 그러나 사용자 경험적으로는 부자연스러운 애니메이션은 인지할 수 없는 지연보다 나쁩니다. 본질적으로 스케줄링이 없으면 모든 업데이트가 동등하게 처리되어 우선순위에 상관없이 즉시 적용됩니다. 스케줄링을 통해 다른 업데이트에 다른 우선순위를 부여할 수 있습니다. 이것이 중요한 경우의 예입니다. 화면에 표시되지 않는 컴포넌트를 업데이트하면 효율적일까요? 그렇지 않습니다. 이 컴포넌트가 화면에 표시되지 않는다면 즉시 렌더링을 시작하는 것은 의미가 없습니다. 이 문제는 목록 뷰를 다룰 때 항상 발생합니다. 사람들이 자주 겪는 일반적인 상황입니다. 목록에 1000개의 항목이 있다고 가정해 보겠습니다. 화면에 표시되지 않는 항목을 고려하지 않는다면, 많은 낭비적인 작업을 수행하게 됩니다. 앱의 응답성이 저하될 것입니다. 이를 해결하기 위해 할 수 있는 한 가지 방법은 화면에 표시되지 않는 항목을 나중에 처리할 수 있도록 우선순위를 낮추는 것입니다. 이렇게 하면 일부 불안정성을 방지할 수 있습니다. React Virtualize는 이렇게 하지 않습니다. 그 대신에 화면에서 너무 멀리 떨어진 항목은 렌더링하지 않는 windowing이라는 방식을 사용합니다. 이것도 해야 할 일이며, Fiber도 이를 도와줄 것이며, 나중에 이에 대해 이야기하겠습니다. 하지만 이는 화면에 표시되지 않는 콘텐츠를 우선순위가 낮은 것으로 설정하는 경우의 예입니다. 스케줄러가 다른 유형의 작업에 우선순위를 부여할 수 있는 경우 이를 수행할 수 있습니다. 이제 예를 하나 보여드리겠습니다. 이것은 이전에 실수로 보여드렸을 때 조금 보셨을 것입니다. 그러나 이제 Fiber와 이 우선순위 개념이 어떻게 작용하는지에 대한 예를 보여드리겠습니다. 이미 여러 번 말했지만, Fiber는 아직 매우 새로운 기술이므로 이 데모는 이상하게 보일 수 있습니다. 왜 이상한 삼각형 데모를 보여주는 거야, Andrew? 하지만 이 데모를 통해 무엇을 보여주려고 하는지 전달할 수 있기를 바랍니다. 재생 중인가요? 설명해 드리겠습니다. 이것은 조금 이상합니다. 우리는 이 큰 삼각형이 있고, 각각의 파란 점은 React 컴포넌트입니다. 이 데모에 대해 알아야 할 몇 가지 사항이 있습니다. 이것은 조금 인위적인 예시입니다. 실제로는 아무도 이런 앱을 만들지 않을 것입니다. 멋지게 보이기는 하지만 아무도 이런 앱을 만들지 않을 것입니다. 알아두어야 할 몇 가지 사항이 있습니다. 각각의 작은 점의 렌더 메서드에는 실제로는 100,000회 반복하는 대규모 while 루프가 있습니다. 그냥 정말 비효율적인 렌더링을 시뮬레이션하기 위해 사용되는 것입니다. 다른 것을 알아두어야 할 것은 매 초마다 숫자가 증가하는 점이 있습니다. 기본적으로 매 초마다 전체 트리를 다시 렌더링해야 새로운 숫자를 얻을 수 있습니다. 그리고 다른 것은 전체 삼각형이 계속 축소 및 확대되고 있다는 것입니다. 그래서 우리가 60프레임씩 계속해서 화면을 갱신하면서 삼각형이 축소 및 확대되고 있습니다. 그리고 React에서는 컨테이너를 다시 렌더링할 때, 컨테이너의 모든 자식도 업데이트된다는 것을 알게 되었습니다. 그래서 매 프레임마다 상위 컴포넌트를 렌더링하는 것입니다. 그러니까 매 프레임마다 상위 컴포넌트의 렌더 메서드를 호출하는 것입니다. 그러면 전체 트리가 다시 렌더링되는 것입니다. 이렇게 컴포넌트를 렌더링하고 비용이 많이 드는 렌더링이라는 것을 알고 있다면, 조심하지 않으면 이것은 정말로 좋지 않을 수 있습니다. 다행히도 우리는 Fiber를 사용하여 스케줄링과 우선순위를 다루고 있으므로 실제로는 아주 잘 작동합니다. 조금은 끊김이 있을 수 있지만, 그건 비디오 때문입니다. 컴퓨터에서 보면 매끄럽게 보입니다. 이제 스케줄링을 사용하지 않는 버전을 보여드리겠습니다. 이것입니다. 여기서는 더 이상 확대 및 축소하지 않습니다. 숫자가 완전히 멈춰 있습니다. 이 색상을 설명하지 않았는데, 이것은 조정의 시각화입니다. 전체 트리의 중간까지도 도달하지 못하고 멈춰 있습니다. 다음 업데이트가 들어오기 전에 전체 트리의 맨 아래까지도 도달하지 못하고 멈춰 있습니다. 많은 작업을 낭비하게 됩니다. 그러나 Fiber 버전에서는 이러한 모든 것을 최상위 애니메이션에 우선순위를 부여하고 나중에 다른 작업을 처리하도록 하고, 그리고 그 순간에 중단된 작업을 다시 시작하여 완료합니다. 그래서 완전히 멈추지 않습니다. 이해가 되지 않는다면, 조금 더 나중에 더 잘 이해하실 수 있을 것입니다. 말로 설명하기는 어렵습니다. 하지만 더 자세한 내용을 알아보겠습니다. 스케줄링과 관련된 것은 동시성이라는 개념입니다. 이것이 Fiber의 핵심이 되는 것이며, 이것이 Fiber를 강력하게 만드는 것입니다. 병렬성이 아니라 동시성입니다. 이 모든 것은 단일 스레드에서 발생합니다. 그러니까 이게 무슨 의미일까요? 현재 버전의 React에서 set state를 호출하면 전체 서브트리가 재귀적으로 동기적으로 다시 렌더링됩니다. 몇 가지 나쁜 점이 있지만, 실제로는 동기적이고 중단되지 않는 것으로 간주됩니다. 그러나 애니메이션 중에 렌더링을 수행하고 있는 경우에는 어떻게 될까요? 두 프레임 사이에 있는 경우에는 어떻게 될까요? 일반적으로 1초에 6프레임이 있으므로 약 16밀리초마다 애니메이션이 발생해야 합니다. 그러나 그 기한이 도달했을 때 여전히 낮은 우선순위 작업을 수행 중이라면 어떻게 될까요? 스케줄링과 우선순위를 올바르게 처리하려면 낮은 우선순위 작업을 수행 중인 동안 중단하고 높은 우선순위 작업을 수행해야 합니다. 그리고 높은 우선순위 작업이 완료되면 애니메이션이 완료되면 원래의 호출 스택으로 돌아가서 중단된 작업을 다시 시작하고 이전에 중단된 곳부터 계속 진행합니다. 그래서 현재 렌더링 호출 스택을 중단시키려면 어떻게 해야 할까요? 이 함수 호출을 어떻게 중단시킬 수 있을까요? 그래서 이렇게 생각해 보겠습니다. 자바스크립트에서 함수 호출을 어떻게 중단시킬 수 있을까요? 생각해 볼 수 있을까요? 네. 제너레이터입니다. 자바스크립트에는 제너레이터가 있고, 제너레이터를 중단시킬 수 있습니다. 실제로 제너레이터는 동시성 기본 요소를 구현하는 데 사용됩니다. co나 Bluebird spawn을 사용해 본 적이 있나요? 제너레이터는 실제로 존재합니다. 여기에는 사용할 수 없는 이유가 있습니다. 그 이유는 설명하지 않겠습니다. 하지만 이것은 JavaScript에서 동시성을 구현하는 한 가지 방법입니다. 이렇게 생각해 보겠습니다. 디버거 문을 사용하면 함수 호출을 중단시킬 수 있습니다. 이 예제를 사용하여 함수 실행을 일시 중지시킬 수 있다는 것을 보여주기 위해 사용하고 있습니다. 이해하고 있으시겠지만, UI에서 동시성을 구현하기 위해 디버거 문을 사용할 수는 없습니다. 하지만 이 예제를 사용하여 함수 실행을 일시 중지시키는 것이 우리가 실제로 하려는 것과 비슷하다는 것을 보여주기 위해 사용하고 있습니다. 실제로는 좀 더 복잡합니다. 좀 더 고급스럽습니다. 우리가 실제로 하려는 것은 현재 렌더링 호출 스택을 중단시키려는 것입니다. 호출 스택을 어딘가에 저장하고 나중에 다시 사용할 수 있도록 저장하는 것입니다. 그리고 높은 우선순위 작업을 수행해야 합니다. 그래서 높은 우선순위 작업을 수행하고 나서 원래의 호출 스택으로 돌아가서 중단된 작업을 다시 시작하고 이전에 중단된 곳부터 계속 진행합니다. 그래서 Fiber가 하는 일은 이와 유사합니다. 작업을 일시 중지시키고 다른 작업을 완료한 다음 나중에 계속합니다. 제 예시에서는 두 가지 사이에서만 전환했습니다. 그러나 Fiber는 무제한으로 많은 작업을 동시에 수행할 수 있습니다. 어떤 면에서 Fiber는 동시성의 단위입니다. 그리고 그렇게 생각할 때, 개별적인 Fiber는 가상의 호출 스택 프레임과 같다고 생각할 수 있습니다. 호출 스택의 정보가 힙에 저장되어 있으므로 데이터 구조로서 조작할 수 있으며 원하는 대로 실행할 수 있습니다. 그리고 그렇게 스택을 제어할 때 다양한 동시성 기능을 구현할 수 있습니다. 그래서 Fiber는 어떤 의미에서는 동시성의 단위입니다. 그냥 사이드로 말하자면, 이것이 무엇인지 이해하기 어렵다면, 호출 스택에 익숙하지 않다면, 그런 것에 실망하지 마세요. 저도 거의 이해하지 못하고 있습니다. Fiber는 실제로 언어 수준의 개념이며, UI 개발자가 일반적으로 생각하는 것보다 훨씬 낮은 수준의 추상화입니다. React에서 Fiber는 실제로 OCaml에서 사용되는데, 거기서는 고급 동시성 기능인 대수적 효과를 구현하는 데 사용됩니다. 그래서 이는 실제로 언어 수준의 것입니다. 즉시 이해하지 못하더라도 걱정하지 마세요. 여기에는 스택 프레임과 Fiber를 비교한 표가 있습니다. 번역: 그들은 비슷합니다. 그래서 스택 프레임에서는 각 스택 프레임이 어떤 서브루틴이나 함수에 해당합니다. 피버에서는 개념적으로 유사한 것은 피버에 구성 요소 유형이 있고, 그 구성 요소는 함수입니다. 스택 프레임에는 서브루틴의 본문이 있으며, 이는 일부 중첩된 함수 호출을 포함할 수 있습니다. 피버에서는 이러한 중첩된 함수 호출은 단순히 자식들에 해당합니다. 스택 프레임에는 서브루틴이 종료된 후 프로그램이 어디로 돌아가야 하는지를 알려주는 반환 주소가 있습니다. 피버에서는 이는 단순히 트리에서 위에 있는 부모 구성 요소, 즉 부모 구성 요소입니다. 스택 프레임에는 해당 스택 프레임, 해당 함수로의 인수가 있습니다. 그리고 당연히 구성 요소의 경우 입력은 속성입니다. 그리고 스택 프레임에는 반환 값이 있습니다. 그리고 피버에서는 React 구성 요소가 일부 결과 DOM 출력에 해당합니다. 이것은 조금 높은 수준의 개요입니다. 피버가 출시되기 전에 정확한 구현 세부 정보가 여러 번 변경될 것이므로 다시 자세히 설명하지 않겠습니다. 그러나 이것은 스택 프레임과 피버가 매우 유사하다는 일반적인 개념입니다. 그러나 피버에는 React 구성 요소에 특정한 필드도 있고, 실제로는 아무런 유사한 것이 없습니다. 예를 들어, 우선 순위가 있습니다. 우리가 언급했듯이, 각 스택 프레임에는 다른 종류의 작업과 비교하여 어느 수준의 우선 순위를 가져야 하는지를 나타내는 숫자가 있습니다. 메모이즈된 입력을 포함하는 필드가 있습니다. 이를 통해 React는 입력이 변경되지 않았다고 말할 수 있습니다. 이를 다시 렌더링할 필요가 없습니다. 키가 있습니다. React 요소에는 키가 있는 것을 알고 있습니까? 그것은 가상 DOM 차이 비교 또는 조정을 수행할 때 키가 목록의 항목이 어느 위치에 있어야 하는지를 React에 알려주는 것입니다. 다시 말해서, 피버는 동시성의 단위이며, 작업을 청크로 나누는 것을 가능하게 합니다. 이것은 우리가 이전에 논의한 스케줄링과 우선 순위 지정을 구현하는 데 매우 중요합니다. 단위로 작업을 우선 순위를 지정할 수 없습니다. 이것은 스케줄링을 제대로 수행하기 위해 필요한 또 다른 부분입니다. 우리는 우선 순위에 대한 전략을 가지고 있습니다. Fiber는 다른 Fiber에 우선 순위를 할당하는 방법이 있습니다. 우리는 작업을 단위로 분할하는 방법이 필요합니다. 왜냐하면 Fiber가 우리의 작업 단위가 될 것이기 때문입니다. 그러나 우리는 실제로 그 작업을 언제 수행해야 하는지와 나중에 계속할 수 있도록 이벤트 루프에 언제 양보해야 하는지를 결정하는 방법도 필요합니다. 그래서 좀 더 설명해 보겠습니다. 그래서 현대 브라우저는 이상적인 시간에 작업을 예약하기 위해 두 가지 API를 제공합니다. request-animation-frame과 request-addle-callback입니다. 대부분의 사람들은 request-animation-frame이 무엇을 하는지 알고 있을 것입니다. 일반적으로 초당 60 프레임으로 호출되며, 애니메이션 수준의 우선 순위를 가진 작업을 예약하는 데 사용됩니다. 그리고 request-addle-callback은 이것이 좀 더 최근에 알려진 API 일 수도 있습니다. 아마도 크롬에서만 구현되었을 것입니다. 정확한 구현은 아직 브라우저에서 많이 이루어지지 않았습니다. 그러나 이것도 매우 중요한 API입니다. 이것은 브라우저가 중요한 작업을 수행하지 않을 때 브라우저의 유휴 기간 동안 콜백을 예약합니다. 그리고 이를 사용하여 애니메이션 우선 순위보다 낮은 모든 작업을 예약합니다. 기본적으로 애니메이션에 있는 모든 것은 request-ado-callback을 사용하여 예약합니다. 그리고 request-addle-callback의 좋은 점은 콜백을 호출할 때 콜백에 대한 API로서, 유휴 기간이 끝나기 전에 얼마나 많은 시간이 남았는지를 알려준다는 것입니다. 브라우저의 타임라인에서 때때로 이러한 유휴 기간이 있을 수 있다고 상상해 보십시오. request-addle-callback은 우리가 그 유휴 기간의 끝으로 향할 때마다 우리에게 알려줍니다. 그래서 우리는 작업을 중지하고 이벤트 루프로 돌아갈 수 있습니다. 그리고 다음 유휴 콜백이 시작될 때 다시 시작할 수 있습니다. 그래서 네, 이 마감 기한은 React Fiber가 렌더링을 잠시 중단하고 우리가 나중에 계속할 수 있는 더 중요한 작업이 있는지 확인할 수 있도록 합니다. 이것은 매우 고도로 시각화된 것으로, request-animation-frame과 request-addle-callback이 어떻게 우리에게 높은 우선 순위 작업과 낮은 우선 순위 작업 사이에서 양보할 수 있게 해주는지 보여주기 위한 것입니다. 예를 들어, 수행해야 할 낮은 우선 순위 작업이 40개 있다고 가정해 보겠습니다. 위쪽 다이어그램은 이벤트 루프에 양보하지 않고 수행해야 할 모든 작업을 한 번에 수행해야 한다는 것을 보여줍니다. 현재 React 모델에서는 한 프레임만 애니메이션화하기 전에 모든 작업을 한 번에 수행해야 하는 것입니다. 그러나 아래쪽 다이어그램은 양보할 수 있으므로 작업을 네 개의 청크로 나눌 수 있고 그 사이에 여전히 프레임을 애니메이션화할 수 있습니다. 위쪽 버전에서는 애니메이션이 매우 부자연스럽고 끔찍해 보일 것입니다. 아래쪽 버전에서는 다른 작업을 중지하지 않고 이 프레임을 여전히 렌더링할 수 있습니다. 그냥 몇 프레임 뒤에 발생할 뿐이므로 낮은 우선 순위이므로 큰 문제가 되지 않을 것입니다. 그래서 이제 우리의 애니메이션은 훨씬 부드러워질 것입니다. 그리고 사용자 경험도 훨씬 좋아질 것입니다. 이것은 조금 단순화된 것이지만, 기본 아이디어를 전달해 줄 것입니다. 그래서 말했듯이, 일부 브라우저는 RequestIdleCallback을 구현하지 않습니다. 우리는 그것을 가짜로 만들 수 있습니다. 제대로 된 네이티브 버전만큼 좋지는 않을 것입니다. 그러나 가짜 버전은 전혀 양보하지 않는 것보다는 낫습니다. 아마도 브라우저 공급 업체가 이 API를 상당히 빨리 추가할 것입니다. 이제 다른 기능에 대해 조금 더 이야기하고 싶습니다. 이론적으로는 멋진 기능이지만, 이 동시성 기능이 가능하게 하는 몇 가지 구체적인 기능에 대해 이야기하고 싶습니다. 나는 통합 레이아웃이라는 특정 기능에 대해 정말로 흥분되고 있습니다. 이것은 초기 버전에 포함되지 않을 것이지만, 피버를 설계할 때 React 팀이 목표로 삼은 것 중 하나입니다. 너무 많은 시간을 할애할 수 없으므로 간단히 설명하겠습니다. 피버에는 코루틴이라는 내부적으로 사용되는 새로운 동시성 기본 요소가 있습니다. 코루틴은 사용자에게 노출되는 기능은 아니지만, React에서 레이아웃 기본 요소를 구현하는 데 사용될 것입니다. 예를 들어, 이를 위해 실제로 사용할 수 있는 것은 테이블 가상화입니다. 테이블 가상화, 그 윈도잉 알고리즘은 DOM에서 어떤 요소가 있는지 계속 읽을 필요가 없다면 훨씬 쉽습니다. Boris가 이전에 이야기한 것처럼, 읽기는 매우 느릴 수 있습니다. 우리가 레이아웃 정보를 직접 제어하면 DOM에서 읽을 필요가 없는 이유가 사라집니다. React는 주어진 스크롤 위치에 대해 어떤 요소와 목록을 렌더링해야 하는지를 결정할 수 있습니다. 이것은 이전에 불가능했던 많은 기능을 열어줍니다. 레이아웃을 제어하는 것은 이전에 불가능했던 많은 기능을 열어줍니다. 그리고 동시성을 가질 수 있는 능력 때문에 가능합니다. React가 페이지의 요소 레이아웃을 완전히 제어하도록 하는 것은 미친 소리처럼 들릴 수 있지만, 이미 React Native가 CSS 플렉스 박스의 자체 구현을 사용하고 있으며, 매우 성공적입니다. 그래서 브라우저가 이전에 수행했던 다른 것을 React가 또 다른 것을 가져가는 것에 대해 공포를 느끼는 것처럼 열린 마음을 가지고 있을 수도 있습니다. 그래서 저는 그것에 대해 매우 흥분하고 있습니다. 그리고 여기에는 React Fiber가 가능하게 할 다른 여러 가지 기능이 있습니다. 하나는 렌더링에서 여러 요소를 반환하는 것입니다. 이것은 매우 자주 요청되는 기능입니다. 이것은 Fiber와 동시성 또는 그와 관련된 것과 전혀 관련이 없습니다. 그저 React의 현재 구현에서는 정말로 어려운 작업입니다. Fiber가 나올 때까지 기다리지 않고 오늘의 React 위에 이를 구현하기로 한 계획입니다. 그러나 이것은 앱에서 여러 항목을 반환하려는 경우에 유용합니다. 그러나 이를 위해 불필요한 Div 요소와 불필요한 Span으로 둘러싸는 경우가 종종 있습니다. 이는 앱 전체에 아무런 기능도하지 않는 이러한 쓰레기 요소를 만들어 내며, CSS 또는 테이블을 사용하는 경우 레이아웃을 불쾌하게 만들 수 있습니다. 이것은 앱에서 불필요한 래퍼 요소의 수를 줄이고, 이 통합 레이아웃이 실현되면 필요한 Div 및 기타 요소의 수를 실제로 줄일 것입니다. 앱이 자체적으로 레이아웃을 제어한다면 아무런 기능도하지 않는 이러한 빈 Div를 사용할 필요가 없습니다. 그래서 그것은 꽤 멋질 것입니다. 그리고 Fiber의 또 다른 좋은 점은 코드 베이스를 정리할 수 있는 기회를 제공한다는 것입니다. 기여를 쉽게 만들기 위해 노력할 것입니다. 그리고 hindsight의 이점을 활용하여 일부 문제를 해결할 수 있습니다. 아마도. 그래서 마무리하면, 아직도 이 모든 것의 의미를 잘 모르는 것 같다면, 한 슬라이드에 요약하면 이렇습니다. 궁극적인 목표는 60프레임으로 렌더링되는 웹 앱입니다. 네이티브 앱과 같이 매끄럽고 원활한 사용자 경험을 제공합니다. 이를 조금 더 구체적으로 설명하자면, 현재 당신의 주머니에는 슈퍼컴퓨터가 있습니다. Tom Acchino가 한 번 내게 말한 것을 요약해 보자면, 왜 우리의 스마트폰은 비디오 게임을 할 때 조금도 끊김없이 1조억개의 다각형을 렌더링할 수 있는데, 끊김없이 목록을 스크롤할 수 없을까요? 그래서 React Fiber가 이러한 문제를 해결하는 데 우리를 더 가깝게 이동시킬 것이라는 희망이 있으며, 우리는 모바일 앱 경험 측면에서 현재까지 네이티브가 분명히 이기고 있는 전쟁에서 웹에서 앱을 더 많이 구축하고 일부 영토를 회복할 수 있기를 바랍니다. 마지막으로 몇 가지 생각을 공유하겠습니다. 반복해서 말하지만, Fiber는 매우 실험적입니다. 이것을 출시한다면 몇 개월이 지날 것입니다. 현재 형태의 Fiber가 출시되지 않더라도 이와 유사한 것이 언젠가는 나올 것입니다. 또 다른 점은 현재 Fiber 작업은 Sebastian Markbage가 주도하고 있습니다. 이름을 제대로 발음하지 못해서 미안합니다. 그리고 Jordan Walk의 프로토타입을 기반으로 많은 다른 똑똑한 사람들의 작업에 크게 의존하고 있습니다. Lee Byron, Pete Hunt 등이 있습니다. 모든 사람들을 기억하지 못할 것입니다. 그러나 Facebook의 많은 사람들이 이러한 작업에 참여하여 몇 년 동안 이러한 작업을 실험하고 새로운 아이디어를 시도했습니다. Fiber는 이전의 모든 노력을 기반으로 합니다. 또 다른 점은 첫 번째 버전은 아마도 새로운 기능을 도입하지 않을 것입니다. 초점은 기능 동등성을 얻는 것입니다. 완전히 다시 작성되었으므로 기존 앱을 섬세한 방식으로 깨뜨리지 않기 위해 신중하게 작업할 것입니다. 또 다른 점은 우선 순위에 대한 많은 이야기를 했습니다. 아마도 처음에는 우선 순위를 지정하지 않을 것입니다. 우선 순위를 노출시키는 경우, 더 높은 수준의 API를 통해 노출될 것입니다. 아이디어는 사용자가 우선 순위에 대해 생각할 필요가 없도록 React가 우선 순위를 지능적으로 처리하도록 하는 것입니다. 예를 들어, 요소에 스타일 디스플레이 없음이 있으면 해당 요소가 화면에서 벗어났다고 추론할 수 있으므로 매우 낮은 우선 순위를 부여할 수 있습니다. 그리고 반대로 키보드를 누르는 결과로 업데이트가 트리거된 경우, 사용자 경험을 즐기기 위해 화면에 빠르게 표시되어야 하는 것이므로 매우 높은 우선 순위를 부여할 것입니다. 그래서 우선 순위 지정에 대한 것을 구현 세부 사항으로 유지하여 사용자가 생각할 필요가 없도록하는 것이 아이디어입니다. 또 다른 점은 GitHub에서 따라가십시오. 말했듯이, 나는 최근에 Facebook에 합류했습니다. 부트 캠프를 마치고 React 팀에 합류할 것입니다. 그러나 이 강연은 사실상 Facebook과의 대화를 시작하기 전에 거의 완전히 작성한 것입니다. 이 모든 것은 외부인의 관점에서 얻은 것입니다. GitHub 커밋을 통해 배운 것입니다. 그것들은 매우 자세합니다. Sebastian은 작업을 진행하면서 그의 작업을 아주 잘 문서화합니다. 그 안에는 매우 흥미로운 통찰력이 있습니다. 나는 그것을 읽으면서 많은 것을 배웠습니다. 나는 React에 이전에 기여한 적이 없습니다. 커뮤니티 작업과 작은 정리 PR만 제출한 적이 있습니다. 그러나 Sebastian의 도움을 많이 받아 최근에 Fiverr에 몇 가지 PR을 제출했고, 최근에 병합되었으며, 이것은 React에 대한 내 첫 번째 중요한 기여입니다. 솔직히 말해서 많은 사람들이 그렇게 할 수 없는 이유는 없다고 생각합니다. Fiverr는 아마도 새로운 기여자가 참여하기에 좋은 기회일 것입니다. 특히 조금 더 완성되고 출시에 가까워질 때. 현재의 React 코드베이스의 혼란스러운 부분이나 기술적인 데이터의 해독을 해야하는 것이 아니라 새로운 것이기 때문에 시작하기에 완벽한 것입니다. 그래서 그것이 끝입니다. 시간이 초과될까봐 걱정했지만, 아직 7분 남았습니다. 그래서 질문이 있으면 답변해 드리겠습니다. 네. 네, 질문하세요. 안녕하세요. 먼저, Fiber는 훌륭한 기능이라고 생각하고 희망합니다. 그리고 두 번째로, React가 이러한 최적화를 효율적으로 수행할 수 있도록 우리의 코드베이스를 어떻게 구성해야 하는지와 관련하여 어떤 권장 사항이 있을까요? 좋은 질문입니다. 질문을 제대로 이해했다면, Fiber가 출시될 때 준비되도록 우리의 React 앱에서 지금 해야 할 일이 있을까요? 그래서 말했듯이, 대부분의 앱은 이상적으로는 그냥 작동할 것입니다. 그러나 라이프사이클 훅과 관련된 몇 가지 사항에서는 약간 까다로울 수 있습니다. 예를 들어, 많은 앱에서는 현재 setState를 호출하면 자식 컴포넌트가 동기적으로 업데이트됩니다. 미래에는 setState가 훨씬 비동기적으로 될 수 있으므로 그 호출이 언제 발생할지에 대해 의존할 수 없게 될 것입니다. 또 다른 예는 일부 라이프사이클 훅이 호출될 수 있지만 실제로 렌더링되지 않을 수 있습니다. 매우 가능성이 높습니다. 나는 이전에 컴포넌트가 마운트될 때 항상 렌더링될 것이라는 가정에 의존하는 코드를 작성한 적이 있습니다. 그것은 또 다른 세심한 것이 깨질 수 있는 것입니다. 그래서 일반적으로 문서를 따르고 너무 벗어나지 않는다면 모든 것이 그냥 작동할 것입니다. 그러나 약간의 이상한 경우가 있을 수 있습니다. 일반적으로 문서를 따르고 너무 벗어나지 않는다면 모든 것이 그냥 작동할 것입니다. 다른 질문이 있습니까? 5분 정도 남았습니다. 그러나 마지막 질문이 될 것입니다. 네, 질문하세요. 안녕하세요. 미안하지만, 답변할 수 있는지 확실하지 않은 질문입니다. 언급한 바와 같이 커뮤니티는 언어 및 브라우저의 제한 사항을 다루기 위한 연령에 접어들고 있는 것 같습니다. 커뮤니티가 브라우저나 언어에 대한 개선 사항이 있는지 또는 언어에 대한 개선 사항이 있는지 알고 있습니까? 네, 이 질문에 대답할 수 있는 사람은 아닐 것입니다. 이것은 Sebastian의 질문입니다. 다시 말하지만, 지금은 무엇을 말하고 있는지 모르는 상태입니다. 제너레이터의 단점 중 하나는 중첩된 제너레이터 또는 각 수준에서 수동으로 언제든지 양보해야 하는 함수가 있어야 한다는 것입니다. 제어입니다. 네, 제어입니다. 아마도 제너레이터로 Fiber와 같은 것을 구현할 수 있을 것입니다. 그러나 Fiber의 소스 코드를 보면, 기본적으로 while 루프의 집합입니다. 아마도 제너레이터로 Fiber와 같은 것을 구현할 수 있을 것입니다. 그러나 Fiber의 소스 코드를 보면, 기본적으로 while 루프의 집합입니다. 그러나 제대로 대답할 수 있는 사람은 아닐 것입니다. 하지만 그것은 그렇게 저레벨의 것에 대해 제대로 된 통제를 제공하지 않습니다. 그 답변이 너무 안 좋지 않길 바랍니다.