톰 오케모입니다. 먼저 크리스, 감사합니다. Facebook에서 자바스크립트 애플리케이션을 개발하는 방식에 대해 조금 이야기해 보겠습니다. 조금 다른 방식으로 진행하려고 합니다. 조던도 발표를 할 예정입니다. 조던이 몇 가지 기술적인 부분을 설명할 겁니다. 저는 좀 더 부드러운 얘기를 할 거예요. 빨리 정리할게요. 우선, 저희는 이 질문을 수없이 많이 했습니다. 자바스크립트 애플리케이션을 어떻게 구조화해야 할까? 좀 더 구체적으로 말하자면 웹 브라우저에서 실행되는 자바스크립트 애플리케이션을 말이죠. 저희도 Node를 사용하여 재미있는 작업을 하고 있지만, 저는 사용자 인터페이스 측면에 더 관심이 많습니다. 그래서 오늘 그 부분에 대해 이야기할 것입니다. 이 질문에 답하기 위한 자바스크립트 프레임워크가 많이 있습니다. 이러한 프레임워크 덕분에 웹이 실제 애플리케이션 플랫폼으로 발전할 수 있었습니다. 피터 히긴스의 말대로 Dojo가 먼저 해냈기 때문에 이 자리에서 Dojo를 언급하고 싶습니다. Dojo는 이미 그렇게 했습니다. 하지만 기본적으로 MVC 스타일의 아키텍처가 가장 좋다는 데는 의견이 일치하고 있으며, MVC만 있는 것은 아닙니다. MVVM 또는 Angular에서는 모델 뷰라고 부르기도 하죠. 저는 이 방식을 정말 좋아합니다. 저는 선언적 데이터 바인딩에서 Angular를 정말 좋아합니다. API 측면에서 일종의 성배라고 생각해요. 하지만 이 모든 아키텍처와 프레임워크에는 한 가지 공통점이 있습니다. 바로 모델입니다. 따라서 일반적으로 이러한 프레임워크의 모델은 이벤트 API로 관찰 가능한 객체를 구현합니다. 개발자는 양방향 데이터 바인딩을 사용하여 뷰를 모델에 바인딩합니다. 모델이 변경되면 뷰도 업데이트될 수 있습니다. 그리고 사용자가 뷰를 변경하면 모델이 업데이트되고, 이는 다른 뷰로 전파됩니다. 따라서 이러한 관찰 가능한 모델 패턴은 변이를 장려합니다. 그리고 변이는 복잡합니다. 그래서 몇 년 전 채팅을 재작성할 때부터 애플리케이션 구조를 조금 다르게 바꾸려고 했습니다. 개발자가 처리해야 하는 돌연변이의 양을 최소화하고 싶었죠. 변이는 필요악입니다. 어쩔 수 없죠. 하지만 개발자가 직접 코딩해야 하는 변이의 양을 최소화하고 싶었습니다. 그래서 제가 무슨 뜻인지 보여드리겠습니다. 다음은 간단한 애플리케이션의 구조입니다. 이 다이어그램에서 모든 업데이트가 하나의 흐름을 거치는 것을 볼 수 있습니다. 따라서 사용자 입력을 포함한 모든 업데이트는 단일 채널을 통과합니다. 이것은 단방향 데이터 바인딩입니다. 이러한 업데이트는 결국 뷰에 도달합니다. 뷰를 구조화하고 렌더링하기 위해 개념적으로 찾은 가장 간단한 방법은 변형을 완전히 피하는 것입니다. 즉, 데이터가 변경될 때마다 뷰를 완전히 날려버리고 처음부터 다시 렌더링하는 것입니다. 무슨 생각인지 잘 알고 있습니다. 그렇게 하면 안 되겠죠? DOM이 느려질 수 있습니다. 브라우저에서 무언가 변경될 때마다 모든 HTML을 다시 작성하려면 비용이 엄청나게 많이 들 것입니다. 특히 실시간 앱이나 인터랙티브한 앱의 경우 더욱 그렇습니다. 그래서 개념적으로는 이것이 우리가 추구하는 것입니다. 이것이 우리가 원하는 것입니다. 모든 이벤트에 대해 처음부터 다시 렌더링할 필요 없이 개념적으로 단순하면서도 오버헤드 없이 렌더링할 수 있는 무언가를 만들고 싶지만, 비용이 엄청나게 많이 들기 때문입니다. 그래서 18개월에서 2년 전쯤, 정확한 날짜는 기억나지 않지만, 이 작업을 도와주는 자바스크립트 라이브러리를 개발하기 시작했고, 우리는 이를 React라고 불렀습니다. 지금까지는 간단한 내용만 말씀드렸고, 이제 Jordan이 나와서 좀 더 기술적인 세부 사항에 대해 이야기해 보겠습니다. 여기까지입니다. 고마워요. 좋아, 토모가 말했듯이 컴포넌트 프레임워크를 구축할 때 우리가 노력하는 것 중 하나는 개발자가 노출되는 변이의 양을 최소화하고 싶다는 것입니다. 그래서 React는 몇 가지 면에서 다른 접근 방식을 취합니다. 첫 번째는 매우 선언적이라는 점입니다. 즉, 초기 렌더링뿐만 아니라 많은 업데이트가 일종의 선언을 통해 구현된다는 뜻입니다. UI가 어떤 모습이어야 하는지에 대한 비변형적인 설명입니다. 좋아요, React 내부에는 관찰 가능한 데이터 바인딩이 없습니다. 함께 제공하지 않습니다. 실제로 React와 함께 사용할 수 있다고 생각하지만, 구현하기 위해 관찰 가능한 데이터 바인딩에 도달할 수 있는 많은 것들을 React는 다른 방법으로 제공합니다. 그리고 선언은 우리가 그렇게 하는 방식입니다. 따라서 React와 함께 임베드 가능한 XML 구문을 출시합니다. 그리고 우리는 이를 JSX라고 부릅니다. 이것은 과거에 일어났던 언어 제안의 많은 작업과 유사하지만 몇 가지 점에서 독특하며, 먼저 어떤 모습인지 살펴보겠습니다. 자, 여기에는 JSX와 함께 React가 사용되었습니다. 그래서 메시지 변수를 생성하고 이를 React div 인스턴스에 할당하고 있습니다. 그리고 거기에 중첩된 내부 div도 있습니다. 따라서 이 div는 여러분이 익숙한 것과는 다릅니다. DOM 노드가 아닙니다. 그래서 특별한 React div입니다. 이것이 왜 중요한지 설명하겠습니다. 맨 아래에서 렌더링합니다. JSX를 독특하게 만드는 한 가지는 매우 가벼운 트랜스폼이라는 점입니다. 우리가 하는 일은 이 태그를 함수 호출로 변환하는 것뿐입니다. 보기에는 좋지 않지만 줄 번호까지 보존하는 것을 볼 수 있습니다. 따라서 이것을 린터에 전달하면 범위를 벗어난 태그를 잡아낼 수 있습니다. 보푸라기 메시지는 모든 항목에서 올바른 줄에 표시됩니다. 여기서 중요한 것은 낮은 툴링입니다. 하지만 JSX는 선택 사항이기도 합니다. React로 빌드하고 싶다면요. 이 방법이 마음에 들면 그렇게 작성해도 되지만, 여러분은 이 방법이 훨씬 낫다는 데 동의할 것입니다. 따라서 React는 단순히 Dom 노드와 Dom 컴포넌트에 관한 것이 아니라, 재사용 가능한 코드를 추상화하고 애플리케이션 UI의 구현 세부 사항을 숨길 수 있는 방법입니다. 따라서 React의 주요 초점은 사용자 정의 컴포넌트를 빌드할 수 있도록 하는 것입니다. 따라서 사용자 정의 컴포넌트를 사용하는 방식은 div나 스팬을 사용하는 방식과 매우 유사하며, XML 구문 JSX를 사용하여 인스턴스화할 수 있으므로 여기에 제공된 XML 어트리뷰트, 텍스트 및 온 액션 콜백이 뷰 인스턴스 또는 React 컴포넌트 인스턴스의 프로퍼티가 될 수 있습니다. 이 액션 버튼을 구현하거나 정의하는 방법을 확인하고 싶으실 텐데요, 몇 가지 알아두셔야 할 것은 React. createClass를 한 번 호출하고 렌더 함수도 제공한다는 것입니다. 이렇게 하면 컴포넌트를 모델링할 클래스가 생성되고, 이 클래스는 확장되거나 React 베이스의 모든 기본 기능을 혼합합니다. 따라서 React는 객체 지향에 초점을 맞춘 프레임워크는 아닙니다. 자바스크립트의 장점에 자연스럽게 부합하기 때문에 약간의 상속을 사용하지만, 그 외에는 핵심 패러다임이 객체 지향이 아니기 때문에 이 점을 말씀드리고 싶었습니다. 따라서 여기에 다른 메서드를 제공하면 프로토타입에 섞여 들어갈 수 있습니다. 따라서 actionButton을 정의하는 순간 실제로 참조할 수 있습니다. 범위 안에 들어가면 린처가 불평하지 않습니다. actionButton이 범위 안에 있지 않으면 린처는 '정의되지 않았습니다'라고 말할 것입니다. 따라서 JSX는 매우 자바스크립트 중심적인 언어입니다. 따라서 렌더링에는 한 가지 목적이 있는데, 바로 특정 시점의 뷰를 설명하는 것입니다. 따라서 초기 렌더링뿐만 아니라 모든 시점을 의미합니다. 이제 일련의 업데이트를 통해 어떤 모습일지 살펴보겠습니다. 자, 여기서는 셸부터 시작하겠습니다. 바깥쪽 버튼과 안쪽 스팬이 있습니다. 따라서 주어진 프로퍼티로 흥미로운 작업을 하고 싶습니다. 속성을 사용자 경험으로 해석할 수 있기를 원합니다. 그래서 우리가 하는 일은 속성 텍스트를 내부 스팬으로 라우팅하고 이 도트 프로퍼티를 통해 전달된 XML 속성을 참조할 수 있는 방식입니다. 따라서 중앙에서 책 비행 텍스트를 내부 스팬으로 라우팅하는 것을 볼 수 있습니다. 하지만 JSX에서 자바스크립트를 사용하고 있고 반응은 자바스크립트 중심이기 때문에 이러한 XML 어트리뷰트는 문자열만 있으면 안 됩니다. 따라서 여기에 제공되고 있는 함수와 동작 콜백이 있고 클릭 시 버튼으로 라우팅하고 있습니다. 따라서 액션 버튼은 이 경우 클릭 시 돔 버튼이므로 적어도 처음에는 반응 컴포넌트를 이러한 프로퍼티에서 사용자 경험으로 변환하는 것으로 보는 것이 도움이 되며 적절한 위치로 라우팅되는 것을 상상할 수 있지만 반응은 단순한 라우팅 도구가 아니라 모든 종류의 변환을 수행하거나 보간 그레이스 내에서 원하는 자바스크립트 표현식을 수행할 수 있으므로 텍스트를 대문자로 바꿀 수 있으므로 텍스트가 변경될 때마다 항상 대문자로 바뀝니다. 따라서 앞서 렌더링에 대해 언급했듯이 렌더링은 초기 렌더링뿐만 아니라 실제로 모든 시점에 대한 렌더링입니다. 따라서 프로퍼티가 변경되면 렌더링 출력도 변경되고 리액트는 렌더링 함수를 만족시킵니다. 사용자 경험은 어느 시점에서든 여러분이 설명한 대로 정확하게 렌더링되도록 보장할 것이므로, 반응은 이를 위해 필요한 최소한의 돔 변이 세트를 찾아낼 것입니다. 예를 들어 텍스트가 변경되었다고 가정하면 react는 변경해야 하는 것은 텍스트 콘텐츠의 가장 안쪽에 있는 것뿐이라는 것을 발견합니다. 어떻게 작동하는지에 대해 조금 더 설명하겠지만 여기서 핵심은 이전에 추상화된 컴포넌트를 다시 추상화할 수 있다는 것입니다. 이미 액션 버튼을 살펴봤는데 이는 단순한 상태 비저장 컴포넌트였지만 결국에는 좀 더 복잡한 것을 만들고 싶을 것입니다. 애플리케이션처럼 자체 내부 상태를 갖는 무언가를 만들고 싶을 것입니다. 그럼 그렇게 해봅시다. 가장 간단한 상태 저장 컴포넌트는 카운터라고 상상할 수 있습니다. 증가 버튼과 감소 버튼이 있으며, 지난 예제에서 만든 액션 버튼을 실제로 재사용하고 있음을 알 수 있습니다. 따라서 두 개의 액션 버튼이 있는데 하나는 증가 버튼이고 다른 하나는 감소 버튼입니다. 이것은 새로운 기능입니다. 애플리케이션을 빌드하고 단순한 상태 비저장 뷰를 원하지 않는다면 일종의 상태 머신을 정의할 수 있기를 원할 것입니다. 컴포넌트가 어떤 식으로든 상태 머신의 역할을 맡을 수 있기를 원할 것입니다. 따라서 상태 머신에는 초기 상태가 필요합니다. 따라서 GetInitialState는 초기 상태를 정의하기 위해 React에서 구현할 수 있는 특수 함수입니다. 이 예제에서는 state의 카운트 멤버를 전달된 초기 카운트 프로퍼티와 같도록 설정하고 있습니다. 그리고 여기 예제에서는 4를 전달합니다. 따라서 상태를 4로 초기화하겠습니다. 여기서 정말 흥미로운 점이 있습니다. 렌더 함수에서 프로퍼티를 참조하고 항상 최신 상태라고 가정할 수 있는 것과 같은 방식으로, React는 이를 보장하기 때문에 렌더 함수 내부에서 state를 참조하고 항상 최신 상태라고 가정할 수도 있습니다. 따라서 프로퍼티나 상태가 변경될 때마다 렌더링은 React 시스템에 의해 만족스러운 상태로 유지됩니다. 따라서 저 H3의 콘텐츠는 항상 상태의 개수를 표시할 것입니다. 그리고 거기에 다시 어떤 표현식을 넣을 수도 있고, 특정 카운트에 따라 렌더링할 내용을 결정하는 터너리를 넣을 수도 있고, 특별한 메시지를 넣을 수도 있습니다. 이러한 상태 변경이 실제로 일어나도록 하려면 카운트에 추가 메서드를 액션의 액션 버튼에 바인딩합니다. 그래서 우리가 1을 증가시킬 때, 우리는 거기에 바인딩했기 때문에 1에 전달되는 카운트를 추가하고 콜백을 추가할 것입니다. 그래서 우리가 하는 일은 컴포넌트의 상태 전환과 같은 상태 머신인 상태를 설정하는 것입니다. 그런 다음 상태 설정은 상태 머신에서 상태 전환을 수행하는 방법입니다. 다음 카운트를 현재 카운트에 델타를 더한 값과 같도록 설정하는 것입니다. 그럼 어떻게 작동할까요? 여기에는 두 가지 주요 패스가 있는데, React 컴포넌트 라이프사이클에는 두 가지 주요 단계가 있습니다. 초기 렌더링이 있습니다. 그리고 유연성을 위해 거대한 마크업 문자열을 계산합니다. 그러면 React가 전체 컴포넌트 계층 구조 트리를 가로지르며 마크업 문자열을 생성하고 렌더링하는 모든 곳에 삽입합니다. 이제 이 초기 단계에 두 번째 단계가 있습니다. 모든 백킹 객체를 인스턴스화하고 모든 이벤트 핸들러를 첨부하는 것입니다. 여기서 흥미로운 점은 이 두 가지 작업이 시스템의 서로 다른 두 곳, 서로 다른 두 대의 컴퓨터, 전 세계 어디에서나 발생할 수 있으므로 이론적으로는 서버에서 마크업을 렌더링한 다음 모든 이벤트 핸들러를 첨부하고 클라이언트에서 모든 백킹 뷰를 인스턴스화하여 완전히 분리된 두 대의 컴퓨터에서 수행할 수 있다는 것입니다. 이에 대해서도 더 많은 이야기를 나눌 수 있습니다. 하지만 컴포넌트 라이프사이클의 두 번째 주요 단계는 이러한 데이터 변경이 발생하는 시기입니다. 따라서 UI를 새로 만들어야 하며, 이것이 바로 조정입니다. 뷰를 업데이트하고, 데이터 원본이 변경될 때마다 UI가 업데이트되도록 하는 것입니다. 따라서 이후의 렌더링 호출을 재귀적으로 비교하고 그 결과를 가져와서 UI가 최신 상태인지 확인하기 위해 가능한 한 가장 작은 차이를 생성하는 것입니다. 따라서 뷰 계층 구조에서 50단계 깊이에 있는 DOM 노드에서 클래스 이름이나 스타일 속성이 하나만 변경되거나 클래스 이름이나 스타일 속성이 하나만 변경되면 기본적으로 이러한 차이점 명령이 이 논리적 브리지를 통해 시스템의 다른 부분으로 직렬화되어 그 가장 작은 변경 사항에 적용됩니다. 다시 한 번 더 자세히 설명하자면, 이 텍스트가 예약 항공편에서 예약 호텔로 변경되는 경우 해당 스팬만 변경되면 실행되는 유일한 DOM 명령은 해당 스팬 간 텍스트가 변경되었는지 확인하는 것이며, 실제로 DOM에서 읽지도 않을 것입니다. 컨퍼런스에서 프레젠테이션을 하는 사람이라면 누구나 가장 인위적인 예제를 보여줄 것입니다. React도 다르지 않지만, React 시스템에는 이스케이프 패치나 여러 가지 이스케이프 패치가 있습니다. 따라서 여러분이 원하는 것 중 일부는 기존 프레임워크나 기존 코드와 통합하고 싶을 것입니다. 그래서 우리는 그렇게 할 수 있는 다양한 방법을 허용합니다. 그리고 또 다른 흥미로운 이스케이프 패치는 사용자가 이 프로세스를 안내하는 데 도움을 줄 수 있는 방법입니다. React는 이 차이점, 즉 적용해야 하는 최소한의 DOM 변경 집합을 찾는데 시간이 걸릴 수 있습니다. 그래서 저희는 사용자가 검색 공간의 많은 부분을 잘라내고 가장 작은 차이점을 찾도록 React를 안내할 수 있도록 허용합니다. 따라서 이러한 기능은 완전히 선택 사항입니다. 코드에 넣을 수도 있고 뺄 수도 있으며, 같은 애플리케이션이 더 빠르거나 느리게 실행될 수 있습니다. 따라서 이 최적화 단계를 개발의 완전히 별개의 부분으로 취급합니다. 핵심이 아닙니다. 최적화부터 시작하는 것이 아니라 병목 현상을 파악하고 필요한 곳에 적용하는 것입니다. 자, 이제 이 이야기는 톰에게 넘기고, 톰이 앞으로 React의 역사에 대해 조금 더 이야기해줄 것입니다. 고마워요, 조던. 네, 이 탈출 해치의 흥미로운 점은 실제로 시간이 지남에 따라 제품을 반복할 수 있는 데 매우 중요하다는 것입니다. 그래서 또 다른 훅은 기본적으로 어느 시점에서든 DOM 노드를 주고 자바스크립트를 작성하도록 할 수 있습니다. 여기 예시 중 하나는 콘텐츠에 맞게 다듬은 것이지만 기본적으로 텍스트 영역을 자동으로 늘리거나 자동 완성기를 수행하는 다른 프레임워크의 다른 플러그인이 있다고 말할 수 있습니다. 그리고 기본적으로 이스케이프 해치를 통해 이러한 것들을 매우 쉽게 연결할 수 있습니다. 이것이 바로 이 프레임워크가 Facebook에서 성공할 수 있었던 이유입니다. 모든 것을 변환할 필요가 없었으니까요. 단편적으로 사용할 수 있었죠. 하지만 이 작업은 오래전부터 시작되었습니다. 아마 18개월 전, 18개월에서 2년 전 사이에 시작된 것 같습니다. 그리고 지금은 facebook.com 전체에서 이 기능을 사용하고 있습니다. 페이스북에서 댓글을 달거나 좋아요를 누른 적이 있다면, 채팅에서 대화를 나눈 적이 있다면, 친구 목록을 통합하거나 사용하거나 알림을 사용해 본 적이 있다면, 정말 오랫동안 다양한 곳에서 이 기능을 사용해 왔습니다. 그리고 저희에게는 정말 정말 잘 작동하고 있습니다. 약 1년 전 Instagram이 Facebook에 합류했을 때 이런 일이 처음 발생했습니다. Facebook의 인프라를 사용하지 않던 다른 곳에서 Facebook의 인프라를 사용하고자 하는 요청이 있었습니다. 과거에 JSConf를 통해 많은 것을 발표했지만, 지금까지는 인프라에서 무언가를 분리하는 것이 매우 어렵다는 변명을 해왔습니다. 하지만 Instagram이 우리와 함께했고 그들은 이것을 정말로 사용하고 싶어했습니다. 그리고 인스타그램은 우리에게 일종의 강제 기능처럼 작용했습니다. 레베카는 코드를 오픈 소스처럼 작성하는 것에 대해 훌륭한 의견을 제시했습니다. 그래서 저희는 모든 React와 모든 빌드 단계, 그리고 그 뒤에 있는 모든 툴을 살펴보기 시작했습니다. 그리고 이를 빌드하거나 리팩토링하고 다시 빌드하여 오픈 소스로 공개하여 Instagram에서 Instagram. 사실 Instagram.com은 이들이 Facebook에 합류한 후 가장 먼저 도전하고 싶었던 프로젝트였습니다. 그리고 1~2주 만에 모든 Instagram. com 프로필을 이 시스템에 구축했는데, 저희로서는 정말 놀라운 일이었습니다. 저희는 정말 흥분했습니다. 기본적으로 이 라이브러리와 다른 라이브러리에서 저희 인프라를 분리하고 집안을 정리하는 강제 기능 역할을 했습니다. 그래서 지금은 모든 Instagram.com이 React를 사용하고 있으며, 외부 클라이언트와 함께 연습할 수 있었습니다. 따라서 이 작업을 해온 모든 사람들을 위한 논리적 다음 단계는 이 라이브러리를 오픈소스화하는 것입니다. 실제로 약 30분 전에 오픈소스를 공개했습니다. Facebook을 확인해보세요. 감사합니다. 감사합니다. 다시 한 번 겸손하게 말씀드리고 싶습니다. 이것은 우리가 사용하고있는 것일뿐입니다. 우리에게 정말 잘 맞는 기능입니다. 피드백을 주시면 정말 감사하겠습니다. 링크를 꼭 확인해 보세요. 피드백에 정말 열려 있습니다. Google 그룹도 있고 IRC 채팅방도 있습니다. 깃허브에도 다양한 종류의 이슈가 있습니다. 그게 바로 리액트이고 감사합니다. 고마워요. 고맙습니다. 고맙습니다. 고맙습니다. 고맙습니다. 고마워요, 스티브. 고마워요, 크리스, 고마워요, 스티븐. 어떻게 작동하는지 보세요. 다시 할 수 있어요 할 수 있어요, 그 데모요